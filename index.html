<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Game Sales Visualizations</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* the background image */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: url("background.jpg") center/cover no-repeat fixed;
            padding: 20px;
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        /* this is for cutting out the edges */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.90);
            border-radius: 0;
            box-shadow: 0 4px 22px rgba(0,0,0,0.35);
            padding: 30px;
            outline: 1px solid #d1d1d1;
        }

        h1 {
            text-align: center;
            color: #222;
            margin-bottom: 10px;
            font-size: 2.4em;
            font-weight: 700;
        }

        .subtitle {
            text-align: center;
            color: #444;
            margin-bottom: 35px;
            font-size: 1.1em;
        }

        
        .chart-container {
            margin-bottom: 55px;
            padding: 18px;
            background: rgba(245, 245, 245, 0.92);
            border-radius: 0;
            border: 1px solid #c8c8c8;
            width: 100%;
        }

        .chart-title {
            font-size: 1.7em;
            color: #222;
            margin-bottom: 18px;
            text-align: center;
            font-weight: 600;
        }

        .chart-description {
            text-align: center;
            color: #555;
            margin-bottom: 28px;
            font-style: italic;
        }

        .axis-label {
            font-size: 14px;
            fill: #555;
        }

        .axis {
            font-size: 12px;
        }

        .grid-line path,
        .grid-line line {
            stroke: #d0d0d0;
            stroke-width: 1;
            stroke-dasharray: 3,3;
        }

        .line {
            fill: none;
            stroke-width: 3;
            stroke-linecap: butt;
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.9rem;
        }

        .legend-color {
            width: 18px;
            height: 18px;
            border-radius: 0 !important;
            outline: 1px solid #333;
        }

        .tooltip {
            position: absolute;
            background: rgba(20, 20, 20, 0.90);
            color: white;
            padding: 10px;
            border-radius: 2px;
            pointer-events: none;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.25s;
            z-index: 999;
        }

        
        .controls-container {
            background: rgba(245,245,245,0.92);
            border-radius: 0;
            padding: 22px;
            border: 1px solid #c8c8c8;
            margin-bottom: 40px;
        }

        .controls-title {
            font-size: 1.3em;
            font-weight: 600;
            text-align: center;
            margin-bottom: 20px;
            color: #222;
        }

        .slider-group, .select-group {
            margin-bottom: 15px;
        }

        .slider-group label,
        .select-group label {
            display: inline-block;
            margin-bottom: 6px;
            font-weight: 500;
        }

        select, .slider {
            border-radius: 0 !important;
        }

        select {
            width: 100%;
            padding: 8px;
            background: white;
            border: 1px solid #777;
            font-size: 1em;
        }

        .slider {
            width: 100%;
            height: 6px;
            background: #bbb;
        }

        .slider::-webkit-slider-thumb {
            width: 18px;
            height: 18px;
            background: #444;
            border-radius: 0;
            cursor: pointer;
        }

        .slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #444;
            border-radius: 0;
            cursor: pointer;
        }

        .loading {
            text-align: center;
            font-size: 1.2em;
            padding: 40px;
            color: #222;
        }

        
        #mapChart {
            width: 100%;
            height: 520px;
        }

        #platform-heatmap {
            overflow-x: auto;
            border: 1px solid #c8c8c8;
            background: #fff;
            padding: 10px;
        }

        #platform-heatmap table {
            border-collapse: collapse;
            width: 100%;
        }

        #platform-heatmap th,
        #platform-heatmap td {
            padding: 6px 10px;
            text-align: center;
            border: 1px solid #bbb;
            font-size: 13px;
            white-space: nowrap;
        }

        #platform-heatmap th {
            background: #eee;
            font-weight: 600;
        }

        #region-select {
            font-size: 16px;
            padding: 6px;
        }
    </style>
</head>

<body>

    <div class="container">
        <h1>Video Game Sales Analysis - Group 4</h1>
        <p class="subtitle">Created by: Sumran, Jay, Aravind</p>

        
        <div class="controls-container">
            <h3 class="controls-title">Filter Controls</h3>

            <div class="slider-group">
                <label>Start Year:</label><br>
                <input type="range" id="minYearSlider" class="slider" min="1980" max="2025" value="1980">
                <span id="minYearValue">1980</span>
            </div>

            <div class="slider-group">
                <label>End Year:</label><br>
                <input type="range" id="maxYearSlider" class="slider" min="1980" max="2025" value="2025">
                <span id="maxYearValue">2025</span>
            </div>

            <div class="select-group">
                <label>Genre Filter:</label>
                <select id="genreSelector">
                    <option value="all">All Genres</option>
                </select>
            </div>
        </div>

        
        <div class="chart-container" id="line-chart-container">
            <h2 class="chart-title">Sales Trends Over Time (Smoothed)</h2>
            <p class="chart-description">3-year rolling average of North American and European (PAL) sales by year</p>
            <div id="line-chart"></div>
            <div class="legend" id="line-legend"></div>
        </div>

        <div class="chart-container" id="bar-chart-container">
            <h2 class="chart-title">Regional Sales Distribution</h2>
            <p class="chart-description">Stacked bar chart showing sales by region over time</p>
            <div id="bar-chart"></div>
            <div class="legend" id="bar-legend"></div>
        </div>

        <div class="chart-container" id="genre-bar-chart-container">
            <h2 class="chart-title">Top Genres by Region</h2>
            <p class="chart-description">Comparing total sales of top genres across different regions</p>
            <div id="genre-bar-chart"></div>
            <div class="legend" id="genre-bar-legend"></div>
        </div>

        <div class="chart-container" id="genre-heatmap-container">
            <h2 class="chart-title">Genre Performance Heatmap</h2>
            <p class="chart-description">Heatmap showing sales intensity by genre and region</p>
            <div id="genre-heatmap"></div>
        </div>

        <div class="chart-container" id="genre-trends-container">
            <h2 class="chart-title">Top Genre Composition by Region Over Time</h2>
            <p class="chart-description">Stacked area chart showing composition of top genres by region</p>
            <div id="genre-trends-chart"></div>
            <div class="legend" id="genre-trends-legend"></div>
        </div>

        
        <div class="chart-container" id="regional-map-container">
            <h2 class="chart-title">Choropleth Map – Regional Sales</h2>
            <p class="chart-description">Total video game sales by region using the same dataset</p>
            <div id="mapChart"></div>
        </div>

        
        <div class="chart-container" id="platform-genre-heatmap-container">
            <h2 class="chart-title">Genre × Platform Heatmap</h2>
            <p class="chart-description">Detailed Breakdown</p>

            <div style="text-align:center; margin-bottom: 10px;">
                <label><b>Region:</b></label>
                <select id="region-select">
                    <option value="NA_Sales">North America</option>
                    <option value="EU_Sales">PAL / Europe</option>
                    <option value="JP_Sales">Japan</option>
                    <option value="Other_Sales">Other</option>
                </select>
            </div>

            <div id="platform-heatmap"></div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
        
        const tooltip = d3.select("#tooltip");
        let fullData = [];

        

        
        function getChartDimensions(dataPointCount = null) {
            const chartContainer = document.querySelector('.chart-container');
            let containerWidth;

            if (chartContainer) {
                const style = window.getComputedStyle(chartContainer);
                const padding = parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
                containerWidth = chartContainer.clientWidth - padding;
            } else {
                const mainContainer = document.querySelector('.container');
                if (mainContainer) {
                    const style = window.getComputedStyle(mainContainer);
                    const padding = parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
                    containerWidth = mainContainer.clientWidth - padding - 40;
                } else {
                    containerWidth = Math.min(1200, window.innerWidth - 100);
                }
            }

            const margin = { top: 40, right: 60, bottom: 80, left: 70 };
            let width = containerWidth - margin.left - margin.right;

            if (dataPointCount && dataPointCount > 0) {
                const minBarWidth = 12;
                const minSpacing = 3;
                const minRequiredWidth = dataPointCount * (minBarWidth + minSpacing);
                width = Math.max(width, minRequiredWidth);
            }

            const height = 450 - margin.top - margin.bottom;
            return { margin, width, height, containerWidth };
        }

        function filterDataByYearRange(data, minYear, maxYear) {
            return data.filter(d => d.Year >= minYear && d.Year <= maxYear);
        }

        
        function applyRollingAverage(data, keys, windowSize = 3) {
            if (!data.length) return data;
            const sorted = data.slice().sort((a, b) => a.year - b.year);
            return sorted.map((d, i) => {
                const start = Math.max(0, i - windowSize + 1);
                const window = sorted.slice(start, i + 1);
                const smoothed = { ...d };
                keys.forEach(k => {
                    const sum = d3.sum(window, w => w[k]);
                    smoothed[k] = sum / window.length;
                });
                return smoothed;
            });
        }

        

        function updateCharts() {
            const minYearSlider = document.getElementById('minYearSlider');
            const maxYearSlider = document.getElementById('maxYearSlider');
            const genreSelector = document.getElementById('genreSelector');

            let minYear = parseInt(minYearSlider.value);
            let maxYear = parseInt(maxYearSlider.value);
            const selectedGenre = genreSelector.value;

            
            if (minYear > maxYear) {
                if (document.activeElement === minYearSlider) {
                    maxYear = minYear;
                    maxYearSlider.value = maxYear;
                } else {
                    minYear = maxYear;
                    minYearSlider.value = minYear;
                }
            }

            document.getElementById('minYearValue').textContent = minYear;
            document.getElementById('maxYearValue').textContent = maxYear;

            let filteredData = filterDataByYearRange(fullData, minYear, maxYear);

            if (selectedGenre !== "all") {
                filteredData = filteredData.filter(d => d.Genre === selectedGenre);
            }

            
            d3.select("#line-chart").selectAll("*").remove();
            d3.select("#bar-chart").selectAll("*").remove();
            d3.select("#genre-bar-chart").selectAll("*").remove();
            d3.select("#genre-heatmap").selectAll("*").remove();
            d3.select("#genre-trends-chart").selectAll("*").remove();
            d3.select("#line-legend").selectAll("*").remove();
            d3.select("#bar-legend").selectAll("*").remove();
            d3.select("#genre-bar-legend").selectAll("*").remove();
            d3.select("#genre-trends-legend").selectAll("*").remove();

            createDualLineChart(filteredData);
            createStackedBarChart(filteredData);
            createGenreByRegionChart(filteredData);
            createGenreHeatmap(filteredData);
            createGenreTrendsChart(filteredData);
        }

        

        d3.csv("vgchartz-2024.csv").then(function(data) {
            data.forEach(d => {
                
                let year = null;

                if (d.release_date) {
                    const dateObj = new Date(d.release_date);
                    if (!isNaN(dateObj)) {
                        year = dateObj.getFullYear();
                    } else {
                        const match = d.release_date.match(/(\d{4})/);
                        if (match) {
                            year = +match[1];
                        }
                    }
                }

                d.Year = year;
                d.Genre = d.genre || "Unknown";

                d.NA_Sales    = +d.na_sales    || 0;
                d.EU_Sales    = +d.pal_sales   || 0;
                d.JP_Sales    = +d.jp_sales    || 0;
                d.Other_Sales = +d.other_sales || 0;

                const parsedTotal = +d.total_sales;
                d.Global_Sales = !isNaN(parsedTotal) && parsedTotal > 0
                    ? parsedTotal
                    : (d.NA_Sales + d.EU_Sales + d.JP_Sales + d.Other_Sales);
            });

            
            fullData = data.filter(d => typeof d.Year === "number" && !isNaN(d.Year) && d.Genre);

            if (!fullData.length) {
                d3.select(".container").html(
                    "<div class='loading'>No valid data after parsing years. Check <strong>release_date</strong> in vgchartz-2024.csv.</div>"
                );
                return;
            }

            
            const genres = Array.from(new Set(fullData.map(d => d.Genre))).sort();
            const genreSelector = document.getElementById('genreSelector');
            genres.forEach(genre => {
                const option = document.createElement('option');
                option.value = genre;
                option.textContent = genre;
                genreSelector.appendChild(option);
            });

            
            const years = fullData.map(d => d.Year);
            const minYear = Math.min(...years);
            const maxYear = Math.max(...years);

            const minSlider = document.getElementById('minYearSlider');
            const maxSlider = document.getElementById('maxYearSlider');

            minSlider.min = minYear;
            minSlider.max = maxYear;
            minSlider.value = minYear;

            maxSlider.min = minYear;
            maxSlider.max = maxYear;
            maxSlider.value = maxYear;

            document.getElementById('minYearValue').textContent = minYear;
            document.getElementById('maxYearValue').textContent = maxYear;

            
            minSlider.addEventListener('input', updateCharts);
            maxSlider.addEventListener('input', updateCharts);
            genreSelector.addEventListener('change', updateCharts);

            
            updateCharts();

            
            createRegionalMap(fullData);
            initPlatformHeatmap(fullData);
        }).catch(function(error) {
            console.error("Error loading data:", error);
            d3.select(".container").html(
                "<div class='loading'>Error loading data. Please ensure <strong>vgchartz-2024.csv</strong> is in the same directory as this HTML file.</div>"
            );
        });

       

        function createDualLineChart(data) {
            const yearData = d3.rollup(
                data,
                v => ({
                    na: d3.sum(v, d => d.NA_Sales),
                    eu: d3.sum(v, d => d.EU_Sales)
                }),
                d => d.Year
            );

            let aggregatedData = Array.from(yearData, ([year, sales]) => ({
                year: +year,
                na: sales.na,
                eu: sales.eu
            })).sort((a, b) => a.year - b.year);

            if (!aggregatedData.length) return;

            const smoothedData = applyRollingAverage(aggregatedData, ["na", "eu"], 3);

            const { margin, width, height, containerWidth } = getChartDimensions(aggregatedData.length);
            const svgWidth = width + margin.left + margin.right;
            const svgHeight = height + margin.top + margin.bottom;

            const svg = d3.select("#line-chart")
                .append("svg")
                .attr("width", svgWidth > containerWidth ? svgWidth : "100%")
                .attr("height", svgHeight)
                .attr("viewBox", `0 0 ${svgWidth} ${svgHeight}`)
                .attr("preserveAspectRatio", svgWidth > containerWidth ? "none" : "xMidYMid meet")
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            const xScale = d3.scaleLinear()
                .domain(d3.extent(smoothedData, d => d.year))
                .range([0, width]);

            const yScale = d3.scaleLinear()
                .domain([0, d3.max(smoothedData, d => Math.max(d.na, d.eu)) * 1.1])
                .nice()
                .range([height, 0]);

            const yAxisGrid = d3.axisLeft(yScale)
                .ticks(8)
                .tickSize(-width)
                .tickFormat("");

            svg.append("g")
                .attr("class", "grid-line")
                .call(yAxisGrid);

            const xAxis = svg.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(
                    d3.axisBottom(xScale)
                        .tickFormat(d3.format("d"))
                        .ticks(Math.min(12, smoothedData.length))
                )
                .attr("class", "axis");

            xAxis.selectAll("text")
                .style("text-anchor", "end")
                .attr("dx", "-.8em")
                .attr("dy", ".15em")
                .attr("transform", "rotate(-45)");

            svg.append("g")
                .call(d3.axisLeft(yScale).tickFormat(d => d + "M"))
                .attr("class", "axis");

            svg.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - margin.left)
                .attr("x", 0 - (height / 2))
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .attr("class", "axis-label")
                .text("Sales (Millions)");

            svg.append("text")
                .attr("transform", `translate(${width / 2}, ${height + margin.bottom - 20})`)
                .style("text-anchor", "middle")
                .attr("class", "axis-label")
                .text("Year");

            const lineNA = d3.line()
                .x(d => xScale(d.year))
                .y(d => yScale(d.na))
                .curve(d3.curveMonotoneX);

            const lineEU = d3.line()
                .x(d => xScale(d.year))
                .y(d => yScale(d.eu))
                .curve(d3.curveMonotoneX);

            svg.append("path")
                .datum(smoothedData)
                .attr("class", "line line-na")
                .attr("stroke", "#4A90E2")
                .attr("d", lineNA);

            svg.append("path")
                .datum(smoothedData)
                .attr("class", "line line-eu")
                .attr("stroke", "#E24A4A")
                .attr("d", lineEU);

            svg.selectAll(".dot-na")
                .data(smoothedData)
                .enter().append("circle")
                .attr("class", "dot-na")
                .attr("cx", d => xScale(d.year))
                .attr("cy", d => yScale(d.na))
                .attr("r", 4)
                .attr("fill", "#4A90E2")
                .on("mouseover", function(event, d) {
                    tooltip.style("opacity", 1)
                        .html(`Year: ${d.year}<br>NA (smoothed): ${d.na.toFixed(2)}M`)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 10) + "px");
                })
                .on("mouseout", () => tooltip.style("opacity", 0));

            svg.selectAll(".dot-eu")
                .data(smoothedData)
                .enter().append("circle")
                .attr("class", "dot-eu")
                .attr("cx", d => xScale(d.year))
                .attr("cy", d => yScale(d.eu))
                .attr("r", 4)
                .attr("fill", "#E24A4A")
                .on("mouseover", function(event, d) {
                    tooltip.style("opacity", 1)
                        .html(`Year: ${d.year}<br>PAL/Europe (smoothed): ${d.eu.toFixed(2)}M`)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 10) + "px");
                })
                .on("mouseout", () => tooltip.style("opacity", 0));

            const legend = d3.select("#line-legend");
            legend.append("div")
                .attr("class", "legend-item")
                .html('<div class="legend-color" style="background: #4A90E2;"></div><span>North America (3-year avg)</span>');
            legend.append("div")
                .attr("class", "legend-item")
                .html('<div class="legend-color" style="background: #E24A4A;"></div><span>PAL / Europe (3-year avg)</span>');
        }

        function createStackedBarChart(data) {
            const yearData = d3.rollup(
                data,
                v => ({
                    na: d3.sum(v, d => d.NA_Sales),
                    eu: d3.sum(v, d => d.EU_Sales),
                    jp: d3.sum(v, d => d.JP_Sales),
                    other: d3.sum(v, d => d.Other_Sales)
                }),
                d => d.Year
            );

            const aggregatedData = Array.from(yearData, ([year, sales]) => ({
                year: +year,
                na: sales.na,
                eu: sales.eu,
                jp: sales.jp,
                other: sales.other,
                total: sales.na + sales.eu + sales.jp + sales.other
            })).sort((a, b) => a.year - b.year);

            if (!aggregatedData.length) return;

            const { margin, width, height, containerWidth } = getChartDimensions(aggregatedData.length);
            const svgWidth = width + margin.left + margin.right;
            const svgHeight = height + margin.top + margin.bottom;

            const svg = d3.select("#bar-chart")
                .append("svg")
                .attr("width", svgWidth > containerWidth ? svgWidth : "100%")
                .attr("height", svgHeight)
                .attr("viewBox", `0 0 ${svgWidth} ${svgHeight}`)
                .attr("preserveAspectRatio", svgWidth > containerWidth ? "none" : "xMidYMid meet")
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            const stack = d3.stack()
                .keys(["na", "eu", "jp", "other"]);

            const stackedData = stack(aggregatedData);

            const xScale = d3.scaleBand()
                .domain(aggregatedData.map(d => d.year))
                .range([0, width])
                .padding(aggregatedData.length > 30 ? 0.1 : 0.15);

            const yScale = d3.scaleLinear()
                .domain([0, d3.max(aggregatedData, d => d.total) * 1.1])
                .nice()
                .range([height, 0]);

            const color = d3.scaleOrdinal()
                .domain(["na", "eu", "jp", "other"])
                .range(["#4A90E2", "#50C878", "#FF6B6B", "#FFD93D"]);

            const yAxisGrid = d3.axisLeft(yScale)
                .ticks(8)
                .tickSize(-width)
                .tickFormat("");

            svg.append("g")
                .attr("class", "grid-line")
                .call(yAxisGrid);

            const xTicks = aggregatedData.length > 20
                ? xScale.domain().filter((d, i) => !(i % 2))
                : xScale.domain();

            svg.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(xScale).tickValues(xTicks))
                .attr("class", "axis")
                .selectAll("text")
                .style("text-anchor", "end")
                .attr("dx", "-.8em")
                .attr("dy", ".15em")
                .attr("transform", "rotate(-45)");

            svg.append("g")
                .call(d3.axisLeft(yScale).tickFormat(d => d + "M"))
                .attr("class", "axis");

            svg.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - margin.left)
                .attr("x", 0 - (height / 2))
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .attr("class", "axis-label")
                .text("Sales (Millions)");

            svg.append("text")
                .attr("transform", `translate(${width / 2}, ${height + margin.bottom - 20})`)
                .style("text-anchor", "middle")
                .attr("class", "axis-label")
                .text("Year");

            const groups = svg.selectAll(".layer")
                .data(stackedData)
                .enter()
                .append("g")
                .attr("class", "layer")
                .attr("fill", d => color(d.key));

            groups.selectAll("rect")
                .data(d => d)
                .enter()
                .append("rect")
                .attr("class", "bar")
                .attr("x", d => xScale(d.data.year))
                .attr("y", d => yScale(d[1]))
                .attr("height", d => yScale(d[0]) - yScale(d[1]))
                .attr("width", xScale.bandwidth())
                .on("mouseover", function(event, d) {
                    const region = d3.select(this.parentNode).datum().key;
                    const regionNames = {
                        na: "North America",
                        eu: "PAL / Europe",
                        jp: "Japan",
                        other: "Other"
                    };
                    tooltip.style("opacity", 1)
                        .html(
                            `Year: ${d.data.year}<br>${regionNames[region]}: ${(d[1] - d[0]).toFixed(2)}M<br>Total: ${d.data.total.toFixed(2)}M`
                        )
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 10) + "px");
                })
                .on("mouseout", () => tooltip.style("opacity", 0));

            const legend = d3.select("#bar-legend");
            const regions = [
                { key: "na", name: "North America", color: "#4A90E2" },
                { key: "eu", name: "PAL / Europe", color: "#50C878" },
                { key: "jp", name: "Japan", color: "#FF6B6B" },
                { key: "other", name: "Other", color: "#FFD93D" }
            ];

            regions.forEach(region => {
                legend.append("div")
                    .attr("class", "legend-item")
                    .html(`<div class="legend-color" style="background: ${region.color};"></div><span>${region.name}</span>`);
            });
        }

        function createGenreByRegionChart(data) {
            if (!data || !data.length) return;

            const genreData = d3.rollup(
                data,
                v => ({
                    na: d3.sum(v, d => d.NA_Sales),
                    eu: d3.sum(v, d => d.EU_Sales),
                    jp: d3.sum(v, d => d.JP_Sales),
                    other: d3.sum(v, d => d.Other_Sales),
                    total: d3.sum(v, d => d.Global_Sales)
                }),
                d => d.Genre
            );

            const aggregatedData = Array.from(genreData, ([genre, sales]) => ({
                genre: genre,
                na: sales.na,
                eu: sales.eu,
                jp: sales.jp,
                other: sales.other,
                total: sales.total
            }))
            .sort((a, b) => b.total - a.total)
            .slice(0, 10);

            if (!aggregatedData.length) return;

            const { margin, width, height, containerWidth } = getChartDimensions(aggregatedData.length);
            const svgWidth = width + margin.left + margin.right;
            const svgHeight = height + margin.top + margin.bottom;

            const svg = d3.select("#genre-bar-chart")
                .append("svg")
                .attr("width", svgWidth > containerWidth ? svgWidth : "100%")
                .attr("height", svgHeight)
                .attr("viewBox", `0 0 ${svgWidth} ${svgHeight}`)
                .attr("preserveAspectRatio", svgWidth > containerWidth ? "none" : "xMidYMid meet")
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            const regions = ["na", "eu", "jp", "other"];
            const regionNames = {
                na: "North America",
                eu: "PAL / Europe",
                jp: "Japan",
                other: "Other"
            };

            const x0 = d3.scaleBand()
                .domain(aggregatedData.map(d => d.genre))
                .range([0, width])
                .padding(0.2);

            const x1 = d3.scaleBand()
                .domain(regions)
                .range([0, x0.bandwidth()])
                .padding(0.05);

            const yScale = d3.scaleLinear()
                .domain([0, d3.max(aggregatedData, d => Math.max(d.na, d.eu, d.jp, d.other)) * 1.1])
                .nice()
                .range([height, 0]);

            const color = d3.scaleOrdinal()
                .domain(regions)
                .range(["#4A90E2", "#50C878", "#FF6B6B", "#FFD93D"]);

            const yAxisGrid = d3.axisLeft(yScale)
                .ticks(8)
                .tickSize(-width)
                .tickFormat("");

            svg.append("g")
                .attr("class", "grid-line")
                .call(yAxisGrid);

            svg.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(x0))
                .attr("class", "axis")
                .selectAll("text")
                .style("text-anchor", "end")
                .attr("dx", "-.8em")
                .attr("dy", ".15em")
                .attr("transform", "rotate(-45)");

            svg.append("g")
                .call(d3.axisLeft(yScale).tickFormat(d => d + "M"))
                .attr("class", "axis");

            svg.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - margin.left)
                .attr("x", 0 - (height / 2))
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .attr("class", "axis-label")
                .text("Sales (Millions)");

            svg.append("text")
                .attr("transform", `translate(${width / 2}, ${height + margin.bottom - 20})`)
                .style("text-anchor", "middle")
                .attr("class", "axis-label")
                .text("Genre");

            const genreGroups = svg.selectAll(".genre-group")
                .data(aggregatedData)
                .enter()
                .append("g")
                .attr("class", "genre-group")
                .attr("transform", d => `translate(${x0(d.genre)},0)`);

            regions.forEach(region => {
                genreGroups.append("rect")
                    .attr("class", "bar")
                    .attr("x", d => x1(region))
                    .attr("y", d => yScale(d[region]))
                    .attr("width", x1.bandwidth())
                    .attr("height", d => height - yScale(d[region]))
                    .attr("fill", color(region))
                    .on("mouseover", function(event, d) {
                        tooltip.style("opacity", 1)
                            .html(
                                `Genre: ${d.genre}<br>${regionNames[region]}: ${d[region].toFixed(2)}M`
                            )
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 10) + "px");
                    })
                    .on("mouseout", () => tooltip.style("opacity", 0));
            });

            const legend = d3.select("#genre-bar-legend");
            regions.forEach(region => {
                legend.append("div")
                    .attr("class", "legend-item")
                    .html(`<div class="legend-color" style="background: ${color(region)};"></div><span>${regionNames[region]}</span>`);
            });
        }

        function createGenreHeatmap(data) {
            if (!data || !data.length) return;

            const genreData = d3.rollup(
                data,
                v => ({
                    na: d3.sum(v, d => d.NA_Sales),
                    eu: d3.sum(v, d => d.EU_Sales),
                    jp: d3.sum(v, d => d.JP_Sales),
                    other: d3.sum(v, d => d.Other_Sales)
                }),
                d => d.Genre
            );

            const genres = Array.from(genreData.keys()).sort();
            const regions = [
                { key: "na", name: "North America" },
                { key: "eu", name: "PAL / Europe" },
                { key: "jp", name: "Japan" },
                { key: "other", name: "Other" }
            ];

            const heatmapData = [];
            genres.forEach(genre => {
                const sales = genreData.get(genre);
                regions.forEach(region => {
                    heatmapData.push({
                        genre: genre,
                        region: region.key,
                        regionName: region.name,
                        sales: sales ? sales[region.key] : 0
                    });
                });
            });

            const maxSales = d3.max(heatmapData, d => d.sales) || 0;
            if (!maxSales) return;

            const { margin, width, height, containerWidth } = getChartDimensions();
            const svgWidth = width + margin.left + margin.right;
            const innerHeight = Math.max(400, genres.length * 25);
            const svgHeight = innerHeight + margin.top + margin.bottom;

            const svg = d3.select("#genre-heatmap")
                .append("svg")
                .attr("width", svgWidth > containerWidth ? svgWidth : "100%")
                .attr("height", svgHeight)
                .attr("viewBox", `0 0 ${svgWidth} ${svgHeight}`)
                .attr("preserveAspectRatio", svgWidth > containerWidth ? "none" : "xMidYMid meet")
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            const xScale = d3.scaleBand()
                .domain(regions.map(r => r.key))
                .range([0, width])
                .padding(0.1);

            const yScale = d3.scaleBand()
                .domain(genres)
                .range([0, innerHeight])
                .padding(0.1);

            const colorScale = d3.scaleSequential(d3.interpolateBlues)
                .domain([0, maxSales]);

            svg.append("g")
                .attr("transform", `translate(0,${innerHeight})`)
                .call(d3.axisBottom(xScale).tickFormat(d => regions.find(r => r.key === d).name))
                .attr("class", "axis");

            svg.append("g")
                .call(d3.axisLeft(yScale))
                .attr("class", "axis");

            svg.selectAll(".heatmap-cell")
                .data(heatmapData)
                .enter()
                .append("rect")
                .attr("class", "heatmap-cell")
                .attr("x", d => xScale(d.region))
                .attr("y", d => yScale(d.genre))
                .attr("width", xScale.bandwidth())
                .attr("height", yScale.bandwidth())
                .attr("fill", d => colorScale(d.sales))
                .on("mouseover", function(event, d) {
                    tooltip.style("opacity", 1)
                        .html(`${d.genre}<br>${d.regionName}: ${d.sales.toFixed(2)}M`)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 10) + "px");
                })
                .on("mouseout", () => tooltip.style("opacity", 0));

            const legendWidth = 200;
            const legendHeight = 20;
            const legendX = width - legendWidth - 10;
            const legendY = 10;

            const legendScale = d3.scaleLinear()
                .domain([0, maxSales])
                .range([0, legendWidth]);

            const legendSvg = svg.append("g")
                .attr("transform", `translate(${legendX},${legendY})`);

            const legendData = d3.range(0, maxSales, maxSales / 100);
            legendSvg.selectAll("rect")
                .data(legendData)
                .enter()
                .append("rect")
                .attr("x", d => legendScale(d))
                .attr("width", legendWidth / 100)
                .attr("height", legendHeight)
                .attr("fill", d => colorScale(d));

            legendSvg.append("text")
                .attr("x", legendWidth / 2)
                .attr("y", legendHeight + 15)
                .style("text-anchor", "middle")
                .style("font-size", "10px")
                .text("Sales (Millions)");

            legendSvg.append("text")
                .attr("x", 0)
                .attr("y", legendHeight / 2 + 3)
                .style("font-size", "10px")
                .text("0");

            legendSvg.append("text")
                .attr("x", legendWidth)
                .attr("y", legendHeight / 2 + 3)
                .style("text-anchor", "end")
                .style("font-size", "10px")
                .text(maxSales.toFixed(1) + "M");
        }

        function createGenreTrendsChart(data) {
            if (!data || !data.length) return;

            const yearGenreData = d3.rollup(
                data,
                v => ({
                    na: d3.sum(v, d => d.NA_Sales),
                    eu: d3.sum(v, d => d.EU_Sales),
                    jp: d3.sum(v, d => d.JP_Sales),
                    other: d3.sum(v, d => d.Other_Sales)
                }),
                d => d.Year,
                d => d.Genre
            );

            const genreTotals = d3.rollup(
                data,
                v => d3.sum(v, d => d.Global_Sales),
                d => d.Genre
            );

            const topGenres = Array.from(genreTotals.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, 6)
                .map(d => d[0]);

            const years = Array.from(yearGenreData.keys()).map(y => +y).sort((a, b) => a - b);
            if (!years.length || !topGenres.length) return;

            const regions = ["na", "eu", "jp", "other"];
            const regionNames = {
                na: "North America",
                eu: "PAL / Europe",
                jp: "Japan",
                other: "Other"
            };

            const allRegionData = {};
            regions.forEach(r => {
                allRegionData[r] = years.map(year => {
                    const genreSales = yearGenreData.get(year);
                    const yearData = { year: year };
                    topGenres.forEach(genre => {
                        yearData[genre] = (genreSales && genreSales.has(genre))
                            ? genreSales.get(genre)[r]
                            : 0;
                    });
                    return yearData;
                });
            });

            const { margin, width, height, containerWidth } = getChartDimensions(years.length);
            const svgWidth = width + margin.left + margin.right;
            const svgHeight = height + margin.top + margin.bottom;
            const chartSpacing = 50;
            const totalHeight = (svgHeight + chartSpacing) * regions.length;

            const svg = d3.select("#genre-trends-chart")
                .append("svg")
                .attr("width", svgWidth > containerWidth ? svgWidth : "100%")
                .attr("height", totalHeight)
                .attr("viewBox", `0 0 ${svgWidth} ${totalHeight}`)
                .attr("preserveAspectRatio", svgWidth > containerWidth ? "none" : "xMidYMid meet");

            regions.forEach((r, idx) => {
                const regionData = allRegionData[r];

                const g = svg.append("g")
                    .attr("transform", `translate(${margin.left},${margin.top + idx * (svgHeight + chartSpacing)})`);

                const stack = d3.stack()
                    .keys(topGenres);

                const stackedData = stack(regionData);

                const xScale = d3.scaleLinear()
                    .domain(d3.extent(regionData, d => d.year))
                    .range([0, width]);

                const yScale = d3.scaleLinear()
                    .domain([
                        0,
                        d3.max(regionData, d => topGenres.reduce((sum, genre) => sum + (d[genre] || 0), 0)) * 1.1
                    ])
                    .nice()
                    .range([height, 0]);

                const color = d3.scaleOrdinal()
                    .domain(topGenres)
                    .range(d3.schemeCategory10);

                const area = d3.area()
                    .x(d => xScale(d.data.year))
                    .y0(d => yScale(d[0]))
                    .y1(d => yScale(d[1]))
                    .curve(d3.curveMonotoneX);

                g.selectAll(".area")
                    .data(stackedData)
                    .enter()
                    .append("path")
                    .attr("class", "area")
                    .attr("d", area)
                    .attr("fill", d => color(d.key))
                    .attr("opacity", 0.7)
                    .on("mousemove", function(event, d) {
                        const [x] = d3.pointer(event, this);
                        const year = Math.round(xScale.invert(x));
                        const regionYearData = regionData.find(row => row.year === year);
                        if (!regionYearData) return;

                        const genre = d.key;
                        const value = regionYearData[genre] || 0;

                        tooltip.style("opacity", 1)
                            .html(
                                `${regionNames[r]}<br>${genre}<br>Year: ${year}<br>Sales: ${value.toFixed(2)}M`
                            )
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 10) + "px");
                    })
                    .on("mouseout", () => tooltip.style("opacity", 0));

                g.append("g")
                    .attr("transform", `translate(0,${height})`)
                    .call(d3.axisBottom(xScale).tickFormat(d3.format("d")).ticks(Math.min(10, years.length)))
                    .attr("class", "axis");

                g.append("g")
                    .call(d3.axisLeft(yScale).tickFormat(d => d + "M"))
                    .attr("class", "axis");

                g.append("text")
                    .attr("x", width / 2)
                    .attr("y", -10)
                    .style("text-anchor", "middle")
                    .style("font-weight", "bold")
                    .style("font-size", "14px")
                    .text(regionNames[r]);
            });

            const legend = d3.select("#genre-trends-legend");
            const legendColor = d3.scaleOrdinal()
                .domain(topGenres)
                .range(d3.schemeCategory10);

            topGenres.forEach(genre => {
                legend.append("div")
                    .attr("class", "legend-item")
                    .html(`<div class="legend-color" style="background: ${legendColor(genre)};"></div><span>${genre}</span>`);
            });
        }

        

        function createRegionalMap(data) {
            const totals = {
                na: d3.sum(data, d => d.NA_Sales),
                eu: d3.sum(data, d => d.EU_Sales),
                jp: d3.sum(data, d => d.JP_Sales),
                other: d3.sum(data, d => d.Other_Sales)
            };

            d3.json("https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson")
                .then(world => {
                    const countries = world.features;

                    const regionMap = {};
                    countries.forEach(c => regionMap[c.id] = "Other");

                    regionMap["USA"] = "North America";
                    regionMap["CAN"] = "North America";
                    regionMap["JPN"] = "Japan";

                    const euList = ["GBR","FRA","DEU","ESP","ITA","NLD","SWE","NOR","FIN","DNK",
                                    "POL","CHE","AUT","BEL","IRL","PRT","GRC","CZE","HUN","ROU","BGR"];
                    euList.forEach(c => regionMap[c] = "PAL / Europe");

                    const max = d3.max(Object.values(totals));

                    const colorScale = d3.scaleLinear()
                        .domain([0, max])
                        .range(["#d7e7ff", "#003366"]);

                    const width = document.getElementById("mapChart").clientWidth || 800;
                    const height = 520;

                    const svg = d3.select("#mapChart").append("svg")
                        .attr("width", width)
                        .attr("height", height);

                    const projection = d3.geoMercator()
                        .scale(width / 2 / Math.PI)
                        .translate([width / 2, height / 1.55]);

                    const path = d3.geoPath().projection(projection);

                    svg.selectAll("path")
                        .data(countries)
                        .enter()
                        .append("path")
                        .attr("d", path)
                        .attr("fill", d => {
                            const r = regionMap[d.id];
                            return colorScale(
                                r === "North America" ? totals.na :
                                r === "PAL / Europe" ? totals.eu :
                                r === "Japan" ? totals.jp :
                                totals.other
                            );
                        })
                        .attr("stroke", "#fff")
                        .on("mousemove", (event,d) => {
                            const r = regionMap[d.id];
                            const val =
                                r === "North America" ? totals.na :
                                r === "PAL / Europe" ? totals.eu :
                                r === "Japan" ? totals.jp :
                                totals.other;

                            tooltip.style("opacity", 1)
                                .html(`<b>${r}</b><br>${val.toFixed(2)}M`)
                                .style("left", event.pageX + 10 + "px")
                                .style("top", event.pageY - 20 + "px");
                        })
                        .on("mouseout", () => tooltip.style("opacity", 0));
                });
        }

        function initPlatformHeatmap(data) {
            const regionSelect = d3.select("#region-select");

            function update(regionField) {
                d3.select("#platform-heatmap").html("");

                const genres = [...new Set(data.map(d => d.Genre))].sort();

                let platforms = [...new Set(
                    data.filter(d => d[regionField] > 0).map(d => d.console)
                )];
                platforms.sort();

                let globalMax = 0;
                const matrix = genres.map(g => {
                    const row = { genre: g };

                    platforms.forEach(p => {
                        const sum = d3.sum(
                            data.filter(x => x.Genre === g && x.console === p),
                            x => x[regionField]
                        );
                        row[p] = sum;
                        if (sum > globalMax) globalMax = sum;
                    });

                    return row;
                });

                const finalMatrix = matrix.filter(r =>
                    platforms.some(p => r[p] > 0)
                );

                const color = d3.scaleLinear()
                    .domain([0, globalMax])
                    .range(["#dce6ff", "#000000"]);

                const table = d3.select("#platform-heatmap").append("table");
                const thead = table.append("thead").append("tr");

                thead.append("th").text("Genre");
                platforms.forEach(p => thead.append("th").text(p));

                const tbody = table.append("tbody");

                finalMatrix.forEach(row => {
                    const tr = tbody.append("tr");
                    tr.append("td").text(row.genre);

                    platforms.forEach(p => {
                        const val = row[p];
                        const bg = color(val);

                        const rgb = d3.rgb(bg);
                        const brightness =
                            rgb.r * 0.299 +
                            rgb.g * 0.587 +
                            rgb.b * 0.114;

                        const textColor = brightness < 120 ? "yellow" : "black";

                        tr.append("td")
                            .style("background", bg)
                            .style("color", textColor)
                            .text(val > 0 ? val.toFixed(2) : "");
                    });
                });
            }

            regionSelect.on("change", function () {
                update(this.value);
            });

            
            update("NA_Sales");
        }
    </script>
</body>
</html>
